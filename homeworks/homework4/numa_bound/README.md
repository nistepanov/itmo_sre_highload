1) Напишем простой скрипт ```cpu_load.py```, 
который будет потреблять все ресурсы конкретного ядра
2) Используя ```numactl``` запустим скрипт с привязкой к одному ядру:
```numactl --physcpubind=0 python3 cpu_load.py &```
```--physcpubind=0``` — указывает привязку к физическому ядру 0 (без изменения привязки памяти). Это означает, что процесс будет выполняться только на ядре 0.
```python3 cpu_load.py``` — это запуск Python-скрипта, который загружает процессор (например, бесконечный цикл).
Символ & запускает процесс в фоновом режиме.
3) Убеждаемся, что скрипт потребляет все ресурсы ядра:
```ps -o pid,cmd,%cpu,%mem,psr -p 4705
    PID CMD                         %CPU %MEM PSR
  4705 python3 cpu_load.py          100  0.0   0
```
4) Устанавливаем FIFO real time политику для процесса
```
sudo chrt -f --pid 1 4705
```

5) Устанавливаем лимит потребления ресурсов ядра для данного процесса, это можно сделать с помощью cgroups
или, например, используя утилиту cpulimit:
```cpulimit -l 75 -p 4705```

6) Запускаем на этом же ядре второй процесс
```numactl --physcpubind=0 python3 cpu_load.py &``` 

7) Проверяем потребление процессов
```ps -o pid,cmd,%cpu,%mem,psr -p 4705
    PID CMD                         %CPU %MEM PSR
   4705 python3 cpu_load.py         84.8  0.0   0
```
```ps -o pid,cmd,%cpu,%mem,psr -p 11918
    PID CMD                         %CPU %MEM PSR
  11918 python3 cpu_load.py         28.2  0.0   0
```
Видим, что объяем потребляемого ресурса первого процесса уменьшился, 
но не стал равным 75%, суммарно процессы при этом потребляют больше 100% ядра.

Причин этому вижу несколько:
1) cpulimit некорректно отработал
2) подобное происходит из-за различных оптимизаций ядра, типа hyper-threading
3) политика FIFO, установленная на первом процессе
4) совокупность п. 1-3
